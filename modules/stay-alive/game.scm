;; Updated!
(define-module (stay-alive game)
  #:use-module (stay-alive dungeon)
  #:use-module (stay-alive level)
  #:use-module (stay-alive item)
  #:use-module (stay-alive weapon)
  #:use-module (stay-alive armor)
  #:use-module (stay-alive agent)
  #:use-module (stay-alive player)
  #:use-module (stay-alive square)
  #:use-module (stay-alive timer)
  #:use-module (stay-alive body)
  #:use-module (shelf shelf)
  #:use-module (shelf shelf-util)
  #:use-module (stay-alive ncurses-interface)
  #:use-module (stay-alive extensions)
  #:use-module (stay-alive util)
  #:use-module (stay-alive lang)
  #:use-module (stay-alive shared)
  #:use-module (stay-alive weight)
  #:use-module (stay-alive delta-queue)
  #:use-module (system base compile)
  #:use-module (system vm program)
  #:use-module (system vm objcode)
  #:use-module (ice-9 receive)
  #:export (the-game the-clock reset-the-game the-game-module)) 

(define (savefile)
  (if (not (file-exists? (string-append (getenv "HOME") "/.stay_alive")))
      (mkdir (string-append (getenv "HOME") "/.stay_alive")))
  (string-append (getenv "HOME") "/.stay_alive/save.go"))

(define the-game-module (current-module))
(define the-game
  (let ((game #f))
    (lambda* (#:optional start-over?)
      (set! game 
	    (cond
	     ((and game (not start-over?)) game)
	     ((and (file-exists? (savefile)) (not start-over?)) 
	      (compile (load-objcode (savefile)) #:from 'objcode #:env the-game-module))
	     (else (instance 
		    Game 
		    #:args (list
			    (instance
			     Player
			     (m (speed 1000)
				(dungeon-name 'main)
				(depth 0)
				(status 'descending-stairs)
				(strength 18)) 
			     #:args `(,(list
					(instance Torch #:args '())
					(instance Buckler #:args '())
					(instance Longsword #:args '())
					(instance Gauntlets #:args '())))))))))
      game)))

(define (reset-the-game)
  (the-game #t))

(define* (the-clock #:optional ticks)
  (if ticks (set! ((the-game) 'clock) (+ ((the-game) 'clock) ticks)))
  ((the-game) 'clock))
(define-object Game
  (initialize! 
   (method (player)
     (set! ($ this 'dungeons) 
	   (h (main (instance StandardDungeon #:args '(main 10)))))
     (set! ($ this 'random-state-datum) 
	   (random-state->datum (random-state-from-platform)))
     (set! ($ this 'clock) 0)
     (set! ($ this 'player) player)))
  (open-level 
   (method ()
     (set! ($ this 'dungeon) 
	   (object-reference 
	    ($ this `(dungeons ,(($ this 'player) 'dungeon-name)))))
     (if (and ($ this 'level #:def #f)
	      (and (eq? ($ this '(level dungeon)) ($ this 'dungeon))
		   (eq? ($ this '(level depth)) ($ this '(player depth)))))
	 ($ this 'level)
	 (begin (if ($ this 'level #:def #f) ($ this 'put-level-async))
		(set! ($ this 'level) 
		      (let ((raw-level 
			     ($ ($ this 'dungeon) 'get-level ($ this '(player depth)))))
			(if (procedure? raw-level) raw-level
			    (compile (bytecode-record-bytecode raw-level) 
				     #:from 'bytecode #:env the-game-module))))
		($ ($ this 'level) 'update-weights! (lambda (tile) ($ tile 'weight)))
		(let ((player ($ this 'player)))
		  ($ ($ this 'level) 'insert-agent player)
		  (set! ($ this 'player) (object-reference player)))
		($ this 'level)))))
  (put-level 
   (method () 
     (if ($ this 'saving-thread #:def #f)
	 (join-thread ($ this 'saving-thread)))
     ($ ($ this 'dungeon) 'cache-level ($ this 'level) the-game-module)))
  (put-level-async 
   (method ()
     (if ($ this 'saving-thread #:def #f)
	 (join-thread ($ this 'saving-thread)))
     (set! ($ this 'saving-thread)
	   (call-with-new-thread 
	    (lambda () 
	      ($ ($ this 'dungeon) 'cache-level ($ this 'level) the-game-module)
	      (set! ($ this 'saving-thread) #f))))))
  (over (method (msg)
	       (finish-message msg)
	       (if (file-exists? "save.go") (delete-file "save.go"))))
  (save (method ()
	  (with-output-to-file 
	      (savefile)
	    (lambda () 
	      (write-objcode 
	       (bytecode-record->objcode (object-compile this the-game-module))
	       (current-output-port))))))
  (play (method (the-screen)
	  (init-display the-screen)      
	  (set! *random-state* (datum->random-state ($ this 'random-state-datum)))
	  (let explore-level ((level ($ this 'open-level))
			      (player ($ this 'player))) 
	    (set! ($ player 'status) 'playing)
	    (let ((paths ($ level 'paths-to-agent player)))
	      (while (eq? ($ player 'status) 'playing) ($ level 'next-turn player)))
	    (case (player 'status)
	      ((quitting) ($ this 'over "you quit"))
	      ((saving)
	       (finish-message "see you later")
	       ($ this 'put-level)
	       ($ this 'save))
	      ((dying) ($ this 'over "you are dead"))
	      (else 
	       (explore-level ($ this 'open-level) player)))))))

(define (finish-message msg) 
  (display-clean-up)
  (display msg)
  (newline))
